syntax = "proto3";

package omni.v1beta6;

import "omni/v1beta6/types/common.proto";
import "omni/v1beta6/types/quote.proto";

////////////////////////////////////////////////////////////////////
// Data structures
////////////////////////////////////////////////////////////////////

// Parameters of settlement specific to corresponding method.
message SettlementMethodParams {
  // The method of settlement.
  SettlementMethod method = 1;

  // The address of the asset used to collect referrer fees for specified settlement method.
  //
  // Might be either offer asset or ask asset.
  Address referrer_fee_asset = 2;

  // The address of the asset used to collect protocol fees for specified settlement method.
  //
  // Might be either offer asset or ask asset.
  Address protocol_fee_asset = 3;

  // The amount of protocol fees specific to corresponding method  in basis points (1/10000 or 0.01%).
  uint32 protocol_fee_bps = 4;
}

////////////////////////////////////////////////////////////////////
// Resolver events
////////////////////////////////////////////////////////////////////

// Notifies the resolver that the quote has been requested by the trader.
message QuoteRequestedEvent {
  // ID of RFQ generated by the server (SHA-256 hex string).
  string rfq_id = 1;

  // The RFQ received from the trader forwarded as is.
  QuoteRequest quote_request = 2;

  // The amount of fees required by the protocol in basis points (1/10000 or 0.01%).
  // **DEPRECATED:** Use fee settings in `settlement_params`.
  uint32 protocol_fee_bps = 3;

  // The timestamp (UTC seconds) of RFQ sent by the trader.
  sint64 request_timestamp = 4;

  // Maximum duration since quote generation before the trader must make valid deposit.
  sint64 quote_validity_timeout = 5;

  // Minimum duration since trader's deposit before the resolver may start settling the trade.
  sint64 deposit_settling_delay = 6;

  // Maximum duration since trader's deposit before the resolver must complete the trade.
  sint64 resolve_timeout = 7;

  // The parameters for each of allowed settlement methods defined by Omniston.
  repeated SettlementMethodParams settlement_method_params = 10;
}

// Notifies the resolver that the RFQ has been cancelled by the trader.
message QuoteRequestCancelledEvent {
  // ID of RFQ from prior `QuoteRequestedEvent` (SHA-256 hex string)
  string rfq_id = 1;
}

// Notifies the resolver that the server accepted the quote sent in `UpdateQuoteRequest`.
//
// The resolver can match `UpdateQuoteRequest` & `QuoteAcceptedEvent` using `seqno` field.
message QuoteAcceptedEvent {
  // ID of quote generated by the server (SHA-256 hex string)
  string quote_id = 1;
}

// Notifies the resolver that the server has rejected the quote sent in `UpdateQuoteRequest`.
//
// The resolver can match `UpdateQuoteRequest` & `QuoteRejectedEvent` using `seqno` field.
message QuoteRejectedEvent {
  QuoteRejectedCode code = 1;
  string message = 2;
}

enum QuoteRejectedCode {
  // Uncategorized error
  UNDEFINED = 0;

  // Invalid value of a parameter (ex: invalid address of an asset, invalid RFQ id, etc).
  INVALID_PARAMETERS = 1;
  // Asset amount restrictions don't pass RFQ requirements
  INVALID_AMOUNTS = 2;
  // Route uses a prohibited intermediate asset
  ROUTE_PROHIBITED = 3;
  // Route uses a unverified or prohibited liquidity pool
  POOL_PROHIBITED = 4;
  // Transaction emulation produced the result different from quote
  EMULATION_RESULT_MISMATCH = 5;
  // The quote is forbidden by the server
  FORBIDDEN = 6;

  // Server errors
  INTERNAL_ERROR = 101;
}

// Notifies the resolver that the server has invalidated the quote as requested by `InvalidateQuoteRequest`.
//
// The resolver can match `InvalidateQuoteRequest` & `QuoteInvalidatedEvent` using `seqno` field.
message QuoteInvalidatedEvent {
}

// Parameters of a trade settled via escrow contract
message EscrowTradeParams {
  // Address of escrow contract.
  Address contract_address = 1;

  // Index of the deposit within escrow contract.
  uint64 deposit_index = 2;

  // Address of the resolver that should receive tokens offered by the trader.
  Address resolver_offer_address = 3;

  // Address of the resolver that must send tokens asked by the trader.
  Address resolver_ask_address = 4;

  // Address of tokens offered by the trader.
  Address offer_asset_address = 5;

  // Address of tokens asked by the trader.
  Address ask_asset_address = 6;

  // Amount of `offer_asset_address` that the resolver will get
  string resolver_offer_units = 7;

  // Amount of `ask_asset_address` that the resolver will pay
  string resolver_ask_units = 8;

  // Max timestamp (UTC seconds) of trade settlement by the resolver.
  //
  // The trader might refund the deposit after this deadline passes.
  uint64 resolve_deadline = 9;
}

// Parameters of an order settled via HTLC contract
message HtlcTradeParams {
  // Address of HTLC contract.
  Address contract_address = 1;

  // ID of order within HTLC contract.
  uint64 deposit_index = 2;

  // Address of the wallet that should receive tokens offered by the order.
  Address taker_address = 3;

  // Address of tokens offered by the order.
  Address asset_address = 4;

  // Amount of `asset_address` that the taker will get
  string amount_units = 5;

  // Max timestamp (UTC seconds) of trade settlement by the resolver.
  uint64 resolve_deadline = 6;

  // Lock hash or data
  string secret_hash = 7;

}

// Notifies the resolver that the trader has deposited tokens to escrow contract.
message TradeStartedEvent {
  // ID of RFQ generated by the server (SHA-256 hex string).
  string rfq_id = 1;

  // ID of quote generated by the server (SHA-256 hex string).
  string quote_id = 2;

  oneof params {
    EscrowTradeParams escrow = 11;
    // TODO: Finish design when implementing support for HTLC settlement
    // HtlcTradeParams htlc = 12;
  }
}

// Notifies the resolver that the trader has disclosed HTLC secret, and it's possible to claim trader's (`offer`) deposit.
message SecretDisclosedEvent {

  // ID of quote generated by the server (SHA-256 hex string).
  string quote_id = 1;
  // Address of HTLC contract within offer blockchain.
  Address contract_address = 2;
  // Index of the offer deposit within a contract.
  uint64 deposit_index = 3;
  // Value of secret to redeem the offer deposit
  string secret = 4;
}

message ResolverEvent {
  // These fields allow multiplexing over a single gRPC stream by matching
  // the requests and corresponding replies sent as `ResolverRequest` & `ResolverEvent`.
  oneof mux {
    // An identifier of event generated by the server.
    // Uniqueness of seqno is only guaranteed within a single connection.
    // When replying to an event, the resolvers must use corresponding `seqno` in `reply_to` field of the reply.
    uint64 seqno = 1;
    // Contains the `seqno` specified in `ResolverRequest` if the event is a reply to a request.
    // Otherwise this field is empty.
    uint64 reply_to = 2;
  }

  // One of resolver's events.
  oneof event {
    QuoteRequestedEvent quote_requested = 10;
    QuoteRequestCancelledEvent quote_request_cancelled = 11;
    QuoteAcceptedEvent quote_accepted = 20;
    QuoteRejectedEvent quote_rejected = 21;
    QuoteInvalidatedEvent quote_invalidated = 22;
    TradeStartedEvent trade_started = 40;
    // TODO: Finish design when implementing support for HTLC settlement
    //SecretDisclosedEvent secret_disclosed = 41;
    KeepAlive keep_alive = 100;
  }
}
